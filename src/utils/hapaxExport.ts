import type { Node, Edge } from '@xyflow/react';
import type { InstrumentNodeData, HapaxDefinition } from '../types';
import { groupBySection, groupNRPNBySection } from './csvParser';

interface ConnectedInstrument {
  node: Node<InstrumentNodeData>;
  hapaxPort: string;
}

// Find all instruments connected to the Hapax's MIDI outputs
export function findConnectedInstruments(
  nodes: Node<InstrumentNodeData>[],
  edges: Edge[]
): ConnectedInstrument[] {
  const hapaxNode = nodes.find((n) => {
    const data = n.data as InstrumentNodeData;
    return data.isHapax;
  });
  if (!hapaxNode) return [];

  const connected: ConnectedInstrument[] = [];

  // Find edges originating from Hapax MIDI outputs
  for (const edge of edges) {
    if (edge.source !== hapaxNode.id) continue;

    // Check if the source handle is a MIDI output (A, B, C, or USB Host)
    const sourceHandle = edge.sourceHandle || '';
    let hapaxPort = 'NULL';

    if (sourceHandle === 'midi-a') hapaxPort = 'A';
    else if (sourceHandle === 'midi-b') hapaxPort = 'B';
    else if (sourceHandle === 'midi-c') hapaxPort = 'C';
    else if (sourceHandle === 'usb-host') hapaxPort = 'USBH';
    else continue; // Skip CV outputs

    const targetNode = nodes.find((n) => n.id === edge.target);
    if (targetNode) {
      const targetData = targetNode.data as InstrumentNodeData;
      if (!targetData.isHapax) {
        connected.push({ node: targetNode, hapaxPort });
      }
    }
  }

  return connected;
}

// Generate a single Hapax definition file content
export function generateHapaxDefinition(definition: HapaxDefinition): string {
  const lines: string[] = [];

  // Header
  const headerName = `${definition.manufacturer.toUpperCase()} ${definition.name.toUpperCase()}`;
  lines.push(`############# ${headerName} #############`);
  lines.push('VERSION 1');
  lines.push(`TRACKNAME ${definition.trackName}`);
  lines.push(`TYPE ${definition.type}`);
  lines.push(`OUTPORT ${definition.outPort}`);
  lines.push(`OUTCHAN ${definition.outChannel}`);
  lines.push('INPORT NULL');
  lines.push('INCHAN NULL');
  lines.push('MAXRATE NULL');
  lines.push('');

  // DRUMLANES section
  lines.push('[DRUMLANES]');
  if (definition.type === 'DRUM' && definition.drumLanes && definition.drumLanes.length > 0) {
    // Sort by lane number descending (higher lanes first, matching Hapax format)
    const sortedLanes = [...definition.drumLanes].sort((a, b) => b.lane - a.lane);
    for (const lane of sortedLanes) {
      // Format: channel:NULL:NULL:note lane_number name
      lines.push(`${lane.channel}:NULL:NULL:${lane.note} ${lane.lane} ${lane.name}`);
    }
  }
  lines.push('[/DRUMLANES]');
  lines.push('');

  // PC section (empty for now)
  lines.push('[PC]');
  lines.push('[/PC]');
  lines.push('');

  // CC section
  lines.push('[CC]');
  if (definition.ccMappings.length > 0) {
    const grouped = groupBySection(definition.ccMappings);
    for (const [section, mappings] of grouped) {
      lines.push(`# ${section}`);
      for (const mapping of mappings) {
        lines.push(`${mapping.ccNumber} ${mapping.paramName}`);
      }
      lines.push('');
    }
  }
  lines.push('[/CC]');
  lines.push('');

  // NRPN section
  lines.push('[NRPN]');
  if (definition.nrpnMappings.length > 0) {
    const grouped = groupNRPNBySection(definition.nrpnMappings);
    for (const [section, mappings] of grouped) {
      lines.push(`# ${section}`);
      for (const mapping of mappings) {
        lines.push(`${mapping.msb}:${mapping.lsb}:7 ${mapping.paramName}`);
      }
      lines.push('');
    }
  }
  lines.push('[/NRPN]');
  lines.push('');

  // ASSIGN section
  lines.push('[ASSIGN]');
  if (definition.assignCCs && definition.assignCCs.length > 0) {
    for (const assign of definition.assignCCs) {
      lines.push(`${assign.ccNumber} ${assign.paramName} ${assign.defaultValue}`);
    }
  }
  lines.push('[/ASSIGN]');
  lines.push('');

  // AUTOMATION section (empty for now)
  lines.push('[AUTOMATION]');
  lines.push('[/AUTOMATION]');
  lines.push('');

  // COMMENT section
  lines.push('[COMMENT]');
  lines.push(`${definition.manufacturer} ${definition.name}`);
  lines.push('Generated by StudioGraph');
  lines.push('[/COMMENT]');

  return lines.join('\n');
}

// Generate definitions for all connected instruments
export function generateAllDefinitions(
  nodes: Node<InstrumentNodeData>[],
  edges: Edge[]
): { nodeId: string; filename: string; content: string }[] {
  const connected = findConnectedInstruments(nodes, edges);
  const definitions: { nodeId: string; filename: string; content: string }[] = [];

  for (const { node, hapaxPort } of connected) {
    const data = node.data as InstrumentNodeData;

    // Create a clean track name (no spaces, short)
    const trackName = data.name.replace(/\s+/g, '').substring(0, 12);

    const definition: HapaxDefinition = {
      name: data.name,
      manufacturer: data.manufacturer,
      trackName,
      type: data.type,
      outPort: hapaxPort,
      outChannel: data.channel,
      ccMappings: data.ccMap,
      nrpnMappings: data.nrpnMap,
      assignCCs: data.assignCCs || [],
      drumLanes: data.drumLanes,
    };

    const content = generateHapaxDefinition(definition);
    const filename = `${data.name.replace(/[^a-zA-Z0-9]/g, '_')}.txt`;

    definitions.push({ nodeId: node.id, filename, content });
  }

  return definitions;
}

// Trigger download of a single file
export function downloadFile(filename: string, content: string): void {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Export all definitions as separate downloads
export function exportAllDefinitions(
  nodes: Node<InstrumentNodeData>[],
  edges: Edge[]
): number {
  const definitions = generateAllDefinitions(nodes, edges);

  for (const { filename, content } of definitions) {
    downloadFile(filename, content);
  }

  return definitions.length;
}
